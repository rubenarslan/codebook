---
title: "Codebook example with Qualtrics dataset"
author: "Ruben Arslan"
date: "`r Sys.Date()`"
output:
  html_vignette:
    fig_width: 7
    fig_height: 6
vignette: >
  %\VignetteIndexEntry{Qualtrics data and metadata}
  \%VignetteKeyword{qualtrics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r message = FALSE}
knit_by_pkgdown <- !is.null(knitr::opts_chunk$get("fig.retina"))
knitr::opts_chunk$set(warning = FALSE, message = FALSE, error = FALSE, echo = TRUE)
ggplot2::theme_set(ggplot2::theme_bw())
library(codebook)
library(dplyr)
```

Here, I try to demonstrate that we can also use the metadata generated by Qualtrics.
Because I am not a Qualtrics user, the developer of the `qualtRics` R package sent
me two example files, one of data and one for metadata, which I use here.
Usually, you'd import these files directly via his package.

## Load
```{r}
# library(qualtRics) # currently not on CRAN, so commented out
results <- readRDS(system.file("extdata", "ryan.rds", package = "codebook"))
metadata_ex <- readRDS(system.file("extdata", "metadata.rds", package = "codebook"))
```

Now, we want the metadata not to be just independent of the data frame.
It's easier to change metadata if it is in the form of a list at the 
dataset level, so let's use `rio::gather_attrs` for that.

```{r}
results <- results %>% rio::gather_attrs()
attributes(results)$label$Q7
```

Now, we can loop over the metadata list and put it in the right shape to become
attributes. This means given each element the name of the variable it refers to.
```{r}
names(metadata_ex$questions) <- lapply(metadata_ex$questions, function(x) {
  x$questionName
})
```

We only want the questions that we have data for.
```{r}
qs <- names(metadata_ex$questions)
qs <- qs[qs %in% names(attributes(results)$label)]
```

Now, we assign our metadata list to the attributes of the data.frame.
```{r}
init <- vector("list", ncol(results)) 
names(init) <- names(results)
attributes(results)$item <- init
attributes(results)$item[qs] <- metadata_ex$questions[qs]
```

And use rio to put the attributes on the question level again.
```{r}
results <- results %>% rio::spread_attrs()
```

To keep this example, we select a subset of variables.
```{r}
results <- results %>% select(ResponseSet, Q7, Q10)
if (!knit_by_pkgdown) knitr::opts_chunk$set(echo = FALSE)
```

Please note, that we just reuse the metadata column names from Qualtrics. Standardising this across multiple survey providers would be great but requires more knowledge of Qualtrics than I have.

```{r}
metadata(results)$name <- "MOCK Qualtrics dataset"
metadata(results)$description <- "a MOCK dataset used to show how to import Qualtrics metadata into the codebook R package"
metadata(results)$identifier <- "doi:10.5281/zenodo.1326520"
metadata(results)$datePublished <- "2018-08-01"
metadata(results)$creator <- list(
      "@type" = "Person",
      givenName = "Ruben", familyName = "Arslan",
      email = "ruben.arslan@gmail.com", 
      affiliation = list("@type" = "Organization",
        name = "MPI Human Development, Berlin"))
metadata(results)$url <- "https://rubenarslan.github.io/codebook/articles/codebook_qualtrics.html"
metadata(results)$temporalCoverage <- "2018" 
metadata(results)$spatialCoverage <- "Nowhere" 
```

```{r}
# We don't want to look at the code in the codebook.
knitr::opts_chunk$set(warning = TRUE, message = TRUE, echo = FALSE)
```

```{r cb}
codebook(results, survey_repetition = "single",
         metadata_table = knit_by_pkgdown, metadata_json = knit_by_pkgdown)
```


`r ifelse(knit_by_pkgdown, '', '### Codebook table')`

```{r}
if (!knit_by_pkgdown) {
  codebook:::escaped_table(codebook_table(results))
}
```

